
// a single line of commented text

import `libraryName` as alias		// import library
limport `libraryName` as alias		// import literate library

if condition then				// equal sign used for equality
	statements					// the off-side rule is used for most language structures
elseif condition				// additional conditions can be added
	statements
else							// a catch-all statement is also supported
	statements

loop							// the simple loop construct loops until broken

	if condition then break		// the "break" keyword breaks out of the innermost loop in which it appears

foreach arrayOrList				// the foreach loop can be applied to arrays and lists
	statements					// the iteration variable allows the programmer read-only access to the nth
								// element of the array or list.

var array char bar = `i like "ike's"`		// strings are arrays of characters
					// strings are quoted using the reverse-quote, because it's more rarely used in english than normal quotes

convert someFloat to int32		// type conversions must be explicit


d = (a + b) + c					// the equality sign is used for both equality and assignment
								// use parentheses to group expressions

foo(a,b)						// procedure call with parameters
foo2()							// procedure call without parameters




// all variables, functions and procedures must be declared in module files

var char something = `B`
	// variables need to be initialized on definition, chars need to be quoted, options are separated by whitespace

var list array char something[] = `1`
	// types are listed from the outermost type to innermost type

var table int something[]		// two-dimensional arrays are called "tables"

var struct something
	field int32 fieldname = 7
	field bool fieldname
	field something				// untyped identifiers point to variables within the current module

const float32 pi = 3.14	// constant values must be typed, and must be initialized at declaration time

var array char $bar				// the $ symbol declares that the internal variable "bar" is exposed to other modules as a variable (doesn't override read-only status for constants)

var array char ~bar				// the ~ symbol declares that the internal variable "bar" is exposed to other modules as a constant


defun int32 foo( int32 blah, int32 blah2 )
										// arguments are separated by commas
										// the return keyword specifies the return value
										// all numbers are signed by default; unsigned numbers must 
										// be declared explicitly.

	var int32 something					// local declarations are allowed

	anotherModule.something()			// calls to subroutines in other modules must declare the referenced module alias

	statements
	statements
	statements
	something = something.fieldname		// references to struct fields require periods
	return something

defproc foo( int32 unsigned blah, int32 blah2 )		// type modifiers are separated by whitespace

	statements
	statements
	statements


defun int32 $foo( )						// functions always have return values, but they might not have arguments
										// the $ symbol declares that the internal variable "bar" is exposed to 
										// the main program

	statements
	statements
	statements

defproc foo2( int32 blah )		// procedures don't have return types

	statements
	statements
	statements

defproc recursive foo3()					// procedures don't necessarily have any arguments
											// recursive subroutines must use the keyword "recursive"

	statements
	statements
	statements

type typeName is int32						// programmer-defined types can rename existing types
	operators = FALSE						// optional "operators" flag allows programmers to disable operators for their type
	defun int32 foo(char blah)				// programmers can define type conversion functions for custom types

