
This document describes the source code for a reference compiler for the Straightjacket programming language (to be discussed later).  This program extracts code from a literate source document (if necessary), gathers declarations from header files (if any are declared) and then translates the main program.

<<def>>
header
literate
getChunks
expression_handler
statement_handler
begin
compiler_begin
compiler_1
compiler_end
<</def>>


Here we're pulling the command line arguments.  There should either be two or three arguments.  The first two arguments should be the input and output arguments.  If three arguments exist, then the first argument should be equal to "-l", indicating that the source file was written as a literate document.  If this option is present, the compiler will attempt to extract source code from the input document before it tries to compile the code.

<<begin>>

begin

///////////////////////////////////////////////												///////
///////////////////////////////////////////////												///////
///////////////////////////////////////////////			Beginning of the main program		///////
///////////////////////////////////////////////												///////
///////////////////////////////////////////////												///////

numArgs := ParamCount;

if numArgs = 2 then begin

	firstArg := ParamStr(1);
	secondArg := ParamStr(2);

	If NOT FileExists(firstArg) then begin
		writeln('File "' + firstArg + '" not found.');
		halt;
	end;

	assign(input_file,firstArg);
	reset(input_file);

	assign(final_output,secondArg);

	isLiterate := FALSE;

end;

if numArgs = 3 then begin

	if ParamStr(1) = '-l' then begin

		firstArg := ParamStr(2);
		secondArg := ParamStr(3);
	
		If NOT FileExists(firstArg) then begin
			writeln('File "' + firstArg + '" not found.');
			halt;
		end;
	
		assign(input_file,firstArg);
		reset(input_file);
	
		assign(final_output,secondArg);

		isLiterate := TRUE;

	end;

	if ParamStr(1) <> '-l' then begin
		writeln('The third argument, if it exists, must be this (indicating that the source file is a literate document):  -l');
		halt;
	end;

end;


if numArgs < 2 then begin
	writeln('Wrong number of parameters supplied.  Please specify and input file and an output file and (optionally) a literate flag.');
	halt;
end;

if numArgs > 3 then begin
	writeln('Wrong number of parameters supplied.  Please specify and input file and an output file and (optionally) a literate flag.');
	halt;
end;

modulePath := TStringList.Create;

identifierList := TStringList.Create;
callList := TStringList.Create;

currentModule := 'root';
currentSub := '';
subrParams := '';
privacyFlag := '0';			// all members are private for now
numParameters := '0';		// parameters not supported yet

currentLineNumber := 0;
mainCount := 0;

<</begin>>



<<compiler_begin>>
///////////////////////////////////////////////												///////
///////////////////////////////////////////////			Beginning of compiler section		///////
///////////////////////////////////////////////												///////
<</compiler_begin>>


Now let's actually use this procedure: 

<<compiler_begin>>

if isLiterate = TRUE then literate(input_file);
if isLiterate = FALSE then close(input_file);

//mode := 1;

<</compiler_begin>>


Next, we want to loop through the input file (whether or not it came from a literate source file), breaking up each line into chunks.  Breaking up each input line is a process we'll repeat in several sections of code, so it's convenient to move this code into a separate procedure.  Let's look at the code for this procedure.  First, of course, we have to define the procedure, declare its local variables and set the initial values of the variables we're going to use.

<<getChunks>>

///////////////////////////////////////////////									///////
///////////////////////////////////////////////			Procedure getChunks		///////
///////////////////////////////////////////////									///////

procedure getChunks (var chunkyFile:text);

var filledLineNum		:	boolean;
	isString			:	boolean;
	endChunk			:	boolean;
	parenEnclosed		:	boolean;
	charFound			:	boolean;

	lineNumStr			:	string;

	numChunk			:	integer;
	numLParens			:	integer;
	numRParens			:	integer;

begin

	dumpStr := '';
	lineNumStr := '';
	workingString := '';
	firstChunk := '';
	secondChunk := '';
	thirdChunk := '';
	fourthChunk := '';

	sentenceType := 100;
	numLParens	:= 0;
	numRParens	:= 0;
	countLetters := 1;
	numChunk := 0;

	filledLineNum := FALSE;
	isString := FALSE;
	endChunk := FALSE;
	parenEnclosed := FALSE;
	isComment := FALSE;
	charFound := FALSE;

<</getChunks>>

Next, we want to read the next line in the current file.  This is pretty easy:

<<getChunks>>
	readln(chunkyFile, workingString);		//writeln('    workingString: ' + workingString);
<</getChunks>>


Next, we need to handle both line numbers and literate inputs.  These tasks should be combined if we want to view all of the line numbering code in one place.

<<getChunks>>

	tabCount := 0;

	if isLiterate = FALSE then currentLineNumber := currentLineNumber + 1;

	if isLiterate = TRUE then begin

		while filledLineNum = FALSE do begin

			if midStr(workingString,countLetters,1) <> ' ' then lineNumStr := lineNumStr + midStr(workingString,countLetters,1);

			if midStr(workingString,countLetters,1) = ' ' then begin
				filledLineNum := TRUE;
				if lineNumStr <> '' then currentLineNumber := currentLineNumber + 1;
			end;

			if filledLineNum = FALSE then countLetters := countLetters + 1;

		end;

	end;
<</getChunks>>

Next, we fill dumpStr with portions of workingString.  As we identify chunks of text that should be separated from one another, we can copy dumpStr into the various chunks, empty dumpStr and then continue forward until we reach the end of the string.  As we do this, we have to keep track of several different kinds of strings:

- words separated by whitespace
- quoted strings (surrounded by reverse quotes, and possibly containing whitespace)
- groups of parentheses, possibly containing whitespace and/or quoted strings

<<getChunks>>
	while countLetters <= length(workingString) do begin

		if isComment = FALSE then begin

			if isString = TRUE then begin
				if midStr(workingString,countLetters,1) <> '`' then dumpStr := dumpStr + midStr(workingString,countLetters,1);

				if midStr(workingString,countLetters,1) = '\' then begin	// allow reverse accents to be included when preceded by backslashes
					if midStr(workingString,countLetters+1,1) = '`' then begin
						dumpStr := dumpStr + midStr(workingString,countLetters+1,1);
						countLetters := countLetters + 1;
					end;
				end;

				if midStr(workingString,countLetters,1) = '`' then begin
					isString := FALSE;
					if countLetters < length(workingString) then countLetters := countLetters + 1;
					if countLetters = length(workingString) then endChunk := TRUE;
				end;
			end;

			if isString = FALSE then begin

				if parenEnclosed = TRUE then begin
					if midStr(workingString,countLetters,1) = '(' then begin
						numLParens := numLParens + 1;
						dumpStr := dumpStr + lowercase(midStr(workingString,countLetters,1));
					end;

					if midStr(workingString,countLetters,1) = ')' then begin	// when the number of right-hand parentheses matches
																				// the number of left-hand parentheses, the chunk is ended

						dumpStr := dumpStr + lowercase(midStr(workingString,countLetters,1));
						numRParens := numRParens + 1;

						if numRParens = numLParens then begin
							endChunk := TRUE;
							parenEnclosed := FALSE;
						end;
					end;
				end;	// if parenEnclosed = TRUE

				if parenEnclosed = FALSE then begin

					if charFound = TRUE then begin
						if endChunk = FALSE then begin
							if midStr(workingString,countLetters,1) = '`' then isString := TRUE;
						end;

						if midStr(workingString,countLetters,1) = ' ' then endChunk := TRUE;
	
						if midStr(workingString,countLetters,1) = chr(9) then endChunk := TRUE;	// after identation is finished, tabs are treated as whitespace

						if midStr(workingString,countLetters,1) = '(' then begin	// count the number of left-hand parentheses
							numLParens := numLParens + 1;
							endChunk := TRUE;
							parenEnclosed := TRUE;
						end;
					end;

					if charFound = FALSE then begin
						if midStr(workingString,countLetters,1) <> chr(9) then begin
							charFound := TRUE;
							numChunk := numChunk + 1;
						end;

						if midStr(workingString,countLetters,1) = chr(9) then tabCount := tabCount + 1;		// only count tabs at the beginning of the line
					end;

				end;	// if parenEnclosed = FALSE


				if midStr(workingString,countLetters,1) = '/' then begin
					if midStr(workingString,countLetters+1,1) = '/' then isComment := TRUE;

				end;

				if isComment = FALSE then begin
				if midStr(workingString,countLetters,1) <> ' ' then begin
				if midStr(workingString,countLetters,1) <> chr(9) then begin
				if midStr(workingString,countLetters,1) <> '(' then begin
				if midStr(workingString,countLetters,1) <> ')' then begin
					dumpStr := dumpStr + lowercase(midStr(workingString,countLetters,1));
				end;
				end;
				end;
				end;
				end;

				if endChunk = TRUE then begin

						if numChunk = 1 then firstChunk := dumpStr;
						if numChunk = 2 then secondChunk := dumpStr;
						if numChunk = 3 then thirdChunk := dumpStr;

						if numChunk <= 3 then dumpStr := '';
						numChunk := numChunk + 1;

						if parenEnclosed = TRUE then dumpStr := dumpStr + lowercase(midStr(workingString,countLetters,1));

						endChunk := FALSE;
						numLParens := 0;
						numRParens := 0;
				end;


	
			end;	// if isString = FALSE
	
	
		end;	// if isComment = FALSE

		countLetters := countLetters + 1;

	end;	// while countLetters <= length(workingString)

	if numChunk = 1 then firstChunk := dumpStr;

	if numChunk = 2 then secondChunk := dumpStr;

	if numChunk = 3 then thirdChunk := dumpStr;

	if numChunk > 3 then fourthChunk := dumpStr;	// whatever we found after the third chunk goes into the fourthChunk

<</getChunks>>

The final thing to do is to set the sentenceType variable.  This will be one of the most important variables used throughout the compiler.

<<getChunks>>
	//
	//	set sentence types
	//

	if fourthChunk = '' then begin
		if thirdChunk = '' then begin
			if secondChunk = '' then begin
				if firstChunk = 'halt' then sentenceType := 14;		// found halt statement
				if firstChunk = '' then sentenceType := 18;			// found blank line
			end;
		end;

		if secondChunk = 'is' then sentenceType := 16;				// found type conversion

		if secondChunk = '=' then sentenceType := 4;				// found assignment statement

		if thirdChunk = '' then begin
			if leftStr(secondChunk,1) = '(' then begin
				if rightStr(secondChunk,1) = ')' then sentenceType := 6;	// found a procedure call
			end;
		end;
	end;

	if fourthChunk <> '' then begin
		if firstChunk = 'import' then sentenceType := 0;			// found import statement
		if firstChunk = 'limport' then sentenceType := 17;			// found literate import statement

		if thirdChunk = 'is' then begin
			if firstChunk = 'var' then sentenceType := 5;			// found variable declaration
			if firstChunk = 'constant' then sentenceType := 15;		// found constant declaration
		end;
	end;


	if firstChunk = 'defproc' then sentenceType := 3;				// found procedure declaration

//	write('    chunks (');	write(sentenceType);	writeln('): ' + firstchunk + ' ' + secondChunk + ' ' + thirdChunk + ' ' + fourthChunk + '|');

end;	// procedure getChunks
<</getChunks>>


First, we want to exclude commented lines, regardless of the mode we're in.  It's no good if we only ignore comments in the program section.

- chunk up the input line

- if you find a tab character, move forward
- if you find a space, error out
- if you find a forward-slash, check the next character for a forward-slash
	- if none, error out
	- if found, mark as single-line comment
- if you find anything else, stop checking the input line for comments



Now let's handle literate header file declarations.  This code is nearly the same as for handling the main file:

<<compiler_1>>
//				if firstChunk = 'limport' then begin
	
//					countLetters := 2;
//					headerString := '';
	
//					while countLetters < length(secondChunk) - 1 do begin
//						if countLetters < length(secondChunk) then headerString := headerString + secondChunk[countLetters];
//						countLetters := countLetters + 1;
//					end;
	
//					assign(module_file, headerString);

//					literate(module_file);

//				end;

//			end;	// if mode = 0

<</compiler_1>>


Every Straightjacket program consists of one or more modules, each of which is stored in a separate text file.  Modules can contain declarations for variables, constants, types, functions and procedures.  By default, these declarations are visible only to the module they're declared within.  Modules can also import other modules, which allows the subroutines in the calling module to access the exported identifiers in the called module.

Every Straightjacket program must include exactly one "main" procedure.  The module that contains this procedure is the root module, and that module identified by a command line argument.  The compiler starts with this module, examining each line.  The beginning of the file may contain zero or more import statements.  If statements are found, the compiler will move to the new module file and look for import statements there.  If an import statement references a module that the compiler has already visited, then the compiler shouldn't switch to that module.  This process ends when there are no more new modules to move to.  The compiler will then process non-import statements in order, moving from the last module added to the root module.

<<compiler_1>>


assign(module_output,'C:\Users\meterwin\Desktop\source code\working\imports.ll');
rewrite(module_output);

dumpStr := '0;root;root;' + firstArg;		// writeln('dumpStr: ' + dumpStr);
modulePath.add(dumpStr);	// modulePath will be used to walk the import tree
currentModuleFile := firstArg;
testModuleEntry := '';

endHeaderLoop := FALSE;
finishedSubr := TRUE;

modulePathCount := 0;
properIndent := 0;




//
// add test info to the output file
//


writeln(module_output,'@msg = internal constant [13 x i8] c"Hello World!\00"');
writeln(module_output,'');
writeln(module_output,'declare i32 @puts(i8*)');
writeln(module_output,'declare void @exit(i32) noreturn nounwind');


//
// loop through each entry in modulePath
//

while endHeaderLoop = FALSE do begin

	//
	//	re-check the entire list every time, as additional entries may be been added
	//

	endRecheckModulePathList := FALSE;
	modulePathCount := modulePath.Count - 1;
	foundUnusedEntry := FALSE;

	while endRecheckModulePathList = FALSE do begin

		testModuleEntry := modulePath.valueFromIndex[modulePathCount];

		if leftStr(testModuleEntry,1) = '0' then begin
			foundUnusedEntry := TRUE;
			endRecheckModulePathList := TRUE;
		end;

		modulePathCount := modulePathCount - 1;

		if modulePathCount < 0 then begin
			endRecheckModulePathList := TRUE;
			if foundUnusedEntry = FALSE then endHeaderLoop := TRUE;
		end;
	end;


	if foundUnusedEntry = TRUE then begin
		
		modCharNum := 1;
		dumpStr := '';
		modCharTest := 0;

		while modCharNum <= length(testModuleEntry) do begin

			if midStr(testModuleEntry,modCharNum,1) <> ';' then dumpStr := dumpStr + midStr(testModuleEntry,modCharNum,1);

			if midStr(testModuleEntry,modCharNum,1) = ';' then begin
				modCharTest := modCharTest + 1;
				if modCharTest = 3 then currentModule := dumpStr;	// set the module alias
				dumpStr := '';
			end;

			if modCharNum = length(testModuleEntry) then currentModuleFile := dumpStr;	// set the path to the module we're going to process next

			modCharNum := modCharNum + 1;

		end;

		//
		// open currentModuleFile
		//

		writeln;
		writeln('opening file "' + ExtractFileName(currentModuleFile) + '"');

		assign(module_file,currentModuleFile);
		reset(module_file);
		currentLineNumber := 0;

		//
		// loop through module_file
		//

		while not EOF(module_file) do begin

			getChunks(module_file);

			if firstChunk <> '' then begin

				/////////////////////											///////
				/////////////////////			Handle module imports			///////
				/////////////////////											///////

				if sentenceType = 0 then begin

					secondChunk := midStr(secondChunk,2,length(secondChunk)-1);		// writeln('secondChunk: ' + secondChunk);

					foundAlias := FALSE;
					modulePathCount2 := modulePath.count - 1;
					foundDuplicate := FALSE;

					// check for duplicate file paths

					endRecheckModulePathList := FALSE;
					modulePathCount := modulePath.Count - 1;
					foundUnusedEntry := FALSE;

					while endRecheckModulePathList = FALSE do begin

						testModuleEntry := modulePath.valueFromIndex[modulePathCount2];

						if ansiContainsStr(testModuleEntry,secondChunk) then begin
							if not ansiContainsStr(testModuleEntry,';' + fourthChunk + ';') then begin
								foundDuplicate := TRUE;
								endRecheckModulePathList := TRUE;
							end;

							if ansiContainsStr(testModuleEntry,';' + fourthChunk + ';') then begin
								foundAlias := TRUE;
								endRecheckModulePathList := TRUE;
							end;
						end;

						modulePathCount2 := modulePathCount2 - 1;

						if modulePathCount2 < 0 then endRecheckModulePathList := TRUE;

					end;


					if foundDuplicate = TRUE then begin

						writeln;
						writeln('found duplicate alias for imported module; unable to proceed.');
						write('    offending module: ');		writeln(currentModule);
						write('    offending line: ');		writeln(currentLineNumber);
						write('    chunks: ');	writeln(firstChunk + ' ' + secondChunk + ' ' + thirdChunk + ' ' + fourthChunk);
						close(module_file);
						close(module_output);
						halt;

					end;


					if foundDuplicate = FALSE then begin
					if foundAlias = FALSE then begin

						moduleNameThrowAway := '0;' + currentModule + ';' + fourthChunk + ';' + secondChunk;	// writeln('moduleNameThrowAway: ' + moduleNameThrowAway);
						modulePath.add(moduleNameThrowAway);	// modulePath will be used to walk the import tree

						writeln;
						writeln('moving to file "' + extractFileName(secondChunk) + '"');
						close(module_file);
						assign(module_file,secondChunk);
						reset(module_file);

						currentLineNumber := 0;
						currentModule := fourthChunk;
						currentModuleFile := secondChunk;

					end;
					end;

				end;	// if sentenceType = 0


<</compiler_1>>

Straightjacket supports two kinds of subroutines; procedures and functions.  Procedures don't return values, and they have access to any identifier within their scope (variables and constants local to them, identifiers global to the current module and identifiers imported from other modules).  Functions do return values, and their scope is more restricted (parameters are read-only and identifiers outside of a function are completely inaccessible).

(In this version of the compiler, only procedures are supported.)

In Straightjacket, procedure definitions look like this:

	defproc foo()
		something

In the example above, the placeholder "something" is indented.  Like Python, Straightjacket uses indentation to determine scope.  In LLVM, a procedure definition looks like this:

	define fastcc void @root.proc(){
	entry:
	something
	ret void
	}

The keyword "fastcc" tells LLVM to use the fast calling convention.  Like C, LLVM represents procedures as functions with no return values, so we have to use the "void" keyword here.  The main procedure is a special case.  As far as Straightjacket is concerned, main() is a procedure because it doesn't supply a value to an expression.  However, it must still return a value to the operating system itself.  For this reason, the LLVM representation of main() looks like this:

	define fastcc i32 @main(){
	entry:
	something
	ret i32 0
	}

The keyword "i32" defines a a 32-bit integer, and returning a value of 0 indicates to the operating system that the program has terminated successfully (as opposed to catastrophically).

<<compiler_1>>

				/////////////////////													///////
				/////////////////////			Handle subroutine definitions			///////
				/////////////////////													///////

				subrType := 0;
				if sentenceType = 3 then subrType := 3;

				if subrType <> 0 then begin		// found a subroutine definition

					// wrap up currentSub

					if currentSub <> '' then begin	// we're already in the middle of a procedure declaration

						close(module_output);
						append(module_output);

						if currentSub = 'main' then begin
							writeln(module_output,'ret i32 0');
							writeln(module_output,'}');
							writeln(module_output,'');
						end;

						if currentSub <> 'main' then begin
							writeln(module_output,'ret void');
							writeln(module_output,'}');
							writeln(module_output,'');
						end;

						currentSub := '';
						finishedSubr := TRUE;

						properIndent := properIndent - 1;		// we're ending an enclosure, so we should decrement properIndent

					end;

					if currentSub = '' then begin		// handle the first subroutine declaration found

						properIndent := properIndent + 1;		// we're starting an enclosure, so we should increment properIndent

						finishedSubr := FALSE;

						close(module_output);
						append(module_output);
						writeln(module_output,'');

						currentSub := secondChunk;

						if sentenceType = 3 then begin

							// loop through the parameter list to set numParameters and subrParams
							// initially, we'll just have an empty list
							// later, arguments will be separated by commas
							// look at thirdChunk

							// loop from 1 to length(thirdChunk)
								// must begin with open paren
								// firstTerm ends with either whitespace or with comma
								// if it is followed by whitespace, then the next non-whitespace character (in this version) must be a close paren.
								// close paren must not be followed by anything but whitespace
								// update numParameters as we go

							// skip over the first character, which will always be '('
							// ignore whitespace
							// in this version of the compiler, there will either be one or zero parameters; don't need to handle commas

/							if leftStr(currentSub,1) = '$' then begin
								privacyFlag := '1';
								currentSub := rightStr(currentSub,length(currentSub)-1);
							end;

							identifierList.add('0:' + privacyFlag + ':' + numParameters + ':' + currentModule + '.' + currentSub + ':0:' + subrParams);

							// the format is this:  <identifier type>:<privacy flag>:<number of parameters>:<identifier name>:<return type>:<parameter types>

							// need to check for keyword "recursive", so that we can tell llvm to enable tail recursion for recursive subroutines
							// check to see whether procParamCount = length(thirdChunk).  if not, fill a variable with whatever non-whitespace characters we find.
							// if what we find is "recursive", then set a flag.  if not, then error and halt the program.
							// go on to check the rest of the line as well.


							// write down the initial procedure definition

							if currentSub = 'main' then begin

								mainCount := mainCount + 1;

								if currentModule = 'root' then begin
									write(module_output,'define fastcc i32 @');
									write(module_output,currentSub+thirdChunk);		// the third chunk is the (empty) parameter list
								end;

								if currentModule <> 'root' then begin
									writeln('the procedure "main" is special, and should only be specified in the root module.');

									writeln('    currentModule: ' + currentModule);
									writeln('    offending file: ' + currentModuleFile);
									write('    line number: ');  writeln(currentLineNumber);
									write('    line chunks: ');  writeln(firstChunk + ' ' + secondChunk + ' ' + thirdChunk + ' ' + fourthChunk);
									halt;
								end;

								if mainCount > 1 then begin
									writeln('the procedure "main" is special, and should only be specified once.');

									writeln('    currentModule: ' + currentModule);
									writeln('    offending file: ' + currentModuleFile);
									write('    line number: ');  writeln(currentLineNumber);
									write('    line chunks: ');  writeln(firstChunk + ' ' + secondChunk + ' ' + thirdChunk + ' ' + fourthChunk);
									halt;
								end;

							end;

							if currentSub <> 'main' then begin
								write(module_output,'define fastcc void @');
								write(module_output,currentModule);
								write(module_output,'.');
								write(module_output,currentSub+thirdChunk);		// the third chunk is the (empty) parameter list
							end;


							writeln(module_output,'{');

							writeln(module_output,'entry:');

							// hello world code for testing purposes

							writeln(module_output,'	call i32 @puts(i8* getelementptr inbounds ([13 x i8]* @msg, i32 0, i32 0))');

							close(module_output);
							append(module_output);

						end;

						// translate the parameters (not supported in this first version)

					end;


				end;	// if subrType <> 0

<</compiler_1>>

Here, I've separated handling of halt statements because they don't require a check of identifierList.  Halt statements end the program abruptly, regardless of how deeply nested they are.  They look like this in Straightjacket:

	halt

In the LLVM side, I'm calling a C function called exit().  Here's the declaration format for that function (which has to be declared as a global function):

	declare void @exit(i32) noreturn nounwind

Here's the way we call it from within a function:

	call void @exit(i32 1) noreturn nounwind


<<compiler_1>>

				/////////////////////											///////
				/////////////////////			Handle halt statements			///////
				/////////////////////											///////

				if sentenceType = 14 then begin

					close(module_output);
					append(module_output);
					writeln(module_output,chr(9) + 'call void @exit(i32 1) noreturn nounwind');

				end;
<</compiler_1>>

Next, I'm calling the statement handler procedure when a non-halt statement is found.

<<compiler_1>>
				/////////////////////											///////
				/////////////////////			Handle other statements			///////
				/////////////////////											///////

				if subrType = 0 then begin
					if sentenceType <> 14 then statement_handler();
				end;

			end;	// if firstChunk <> ''

		end;	// while not EOF(module_file)

<</compiler_1>>

The following code describes what to do when we reach the end of a module file.  Basically we do two things; we finish writing any procedures that haven't been finished, and we alter the modulePath entry so that we don't process any module more than once.

<<compiler_1>>

		//
		//	when reaching the end of a module file, we need to mark that file as an alias
		//	in the modulePath list so that we don't re-process it.
		//


		if EOF(module_file) = TRUE then begin

			currentLineNumber := 0;

			writeln('found end of module "' + currentModule + '"');

			// if we don't close and re-open the module_output file after reaching the end of the module_file,
			// free pascal will ditch some of the information

			close(module_output);
			append(module_output);

			if finishedSubr = FALSE then begin	// we're already in the middle of a procedure declaration
			if currentSub <> '' then begin
			if firstChunk = '' then begin

				if currentSub = 'main' then begin
					writeln(module_output,'ret i32 0');
					writeln(module_output,'}');
					writeln(module_output,'');
				end;

				if currentSub <> 'main' then begin
					writeln(module_output,'ret void');
					writeln(module_output,'}');
					writeln(module_output,'');
				end;

				currentSub := '';
				finishedSubr := TRUE;

				properIndent := properIndent - 1;		// we're ending an enclosure, so we should decrement properIndent

			end;
			end;
			end;

			close(module_output);
			append(module_output);

			modulePathCount3 := modulePath.count - 1;


			//
			// look for an original entry pointing to the just-closed file so that we can make it an alias
			//


			while modulePathCount3 >= 0 do begin

				testModuleEntry := modulePath.valueFromIndex[modulePathCount3];

				if ansiContainsStr(testModuleEntry,currentModuleFile) = TRUE then begin
				if leftStr(testModuleEntry,1) = '0' then begin

					writeln('testModuleEntry: ' + testModuleEntry);
					writeln('currentModuleFile: ' + currentModuleFile);

					dumpStr := '1' + rightStr(testModuleEntry,length(testModuleEntry) - 1);		//writeln('dumpStr: ' + dumpStr);
					writeln('deleting this entry: ' + modulePath.valueFromIndex[modulePathCount3]);
					modulePath.delete(modulePathCount3);
					modulePath.add(dumpStr);
					writeln('adding this entry: ' + dumpStr);
				end;
				end;

				modulePathCount3 := modulePathCount3 - 1;

			end;

			close(module_file);

		end;	// if EOF(module_file) = TRUE


	end;	// if foundUnusedEntry = TRUE



	//
	//	re-check the entire list every time, as additional entries may be been added
	//

	endRecheckModulePathList := FALSE;
	modulePathCount := modulePath.Count - 1;
	foundUnusedEntry := FALSE;

	while endRecheckModulePathList = FALSE do begin

		testModuleEntry := modulePath.valueFromIndex[modulePathCount];	//writeln('testModuleEntry2: ' + testModuleEntry);

		if leftStr(testModuleEntry,1) = '0' then begin
			foundUnusedEntry := TRUE;
			endRecheckModulePathList := TRUE;
			endHeaderLoop := FALSE;
		end;

		modulePathCount := modulePathCount - 1;

		if modulePathCount < 0 then begin
			endRecheckModulePathList := TRUE;
			if foundUnusedEntry = FALSE then endHeaderLoop := TRUE;
		end;
	end;

end;	// while endHeaderLoop = FALSE

if mainCount = 0 then begin
	writeln('The procedure "main" is special, and must be specified once in the root module.');

	writeln('    currentModule: ' + currentModule);
	writeln('    offending file: ' + currentModuleFile);
	write('    line number: ');  writeln(currentLineNumber);
	write('    line chunks: ');  writeln(firstChunk + ' ' + secondChunk + ' ' + thirdChunk + ' ' + fourthChunk);
	halt;
end;

if finishedSubr = FALSE then begin	// we're already in the middle of a procedure declaration
	if currentSub = 'main' then begin
		writeln(module_output,'ret i32 0');
		writeln(module_output,'}');
		writeln(module_output,'');
	end;

	if currentSub <> 'main' then begin
		writeln(module_output,'ret void');
		writeln(module_output,'}');
		writeln(module_output,'');
	end;
end;

close(module_output);

//end;	// if mode = 1





<</compiler_1>>


Now let's talk about assignments.  In Straightjacket, every line is either an import, a declaration or a statement.  Statements can appear in either a module or in the main program, and for that reason I'll use a procedure call to handle them.  What this procedure will do is determine what kind of statement we have to deal with, double-check that the current statement has the correct indentation (since indentation partially determines scope) and then handles the statement appropriately.  Expressions will be handled by calling the expression_handler function.

<<statement_handler>>

///////////////////////////////////////////////												///////
///////////////////////////////////////////////			Procedure statement_handler			///////
///////////////////////////////////////////////												///////

procedure statement_handler ();

var		numColons					:	integer;
		innerLoopCount				:	integer;
		loopCount					:	integer;
		changeCount					:	integer;
		procNameCount				:	integer;
		loopMCcount					:	integer;
		numPeriodsFound				:	integer;
		charPos						:	integer;
		intSize						:	integer;
		dollarFound					:	integer;
		nthListEntry				:	integer;
		foundDupDecl				:	integer;
		count						:	integer;

		identifierTestModuleName	:	string;
		identifierProcName			:	string;
		identifierTestIDName		:	string;
		testIdentifierEntry			:	string;
		procName					:	string;
		modNameTarget				:	string;
		testModuleName				:	string;
		throwawayModulePath			:	string;
		readOnlyProp				:	string;
		intName						:	string;
		dollarString				:	string;
		testdollarString			:	string;
		dollarNumStr				:	string;
		calledModule				:	string;
		variableValue				:	string;
		testOldValueStr				:	string;

		endSHLoop					:	boolean;
		canCall						:	boolean;
		endInnerLoopProcCall		:	boolean;
		foundProcMatch				:	boolean;
		endMCLoop					:	boolean;
		verifiedCall				:	boolean;
		isProcedure					:	boolean;
		foundDuplicateID			:	boolean;
		foundDollar					:	boolean;
		endDollarLoop				:	boolean;
		foundChar					:	boolean;
		endInnerLoop				:	boolean;
		endLoop						:	boolean;


begin
<</statement_handler>>

The first thing we need to do is to check each entry in identifierList and break it up into several variables.  We will then use these variables to check different types of statements.


<<statement_handler>>

	endSHLoop := FALSE;
	foundDupDecl := 0;

	/////////////////////													///////
	/////////////////////			Handle variable declarations			///////
	/////////////////////													///////

	if sentenceType = 5 then begin

		writeln('found variable declaration "' + secondChunk + '" of type "' + fourthChunk + '".');

		if pos('char',fourthChunk) > 0 then begin

			privacyFlag := '0';
			readOnlyProp := '0';

			if leftStr(secondChunk,1) = '$' then privacyFlag := '1';	// variable exported

			if leftStr(secondChunk,1) = '~' then begin
				privacyFlag := '1';		// variable exported as constant
				readOnlyProp := '1';
			end;

			if identifierList.count = 0 then foundDupDecl := 0;

		end;	// if pos('char',fourthChunk) > 0


		//
		//	only ascii characters are supported at this time
		//

		if pos('char',fourthChunk) = 0 then begin
			writeln('Found unrecognized type name.  Halting compilation.');
			writeln('    offending file: ' + currentModuleFile);
			write('    line number: ');  writeln(currentLineNumber);
			write('    line chunks: ');  writeln(firstChunk + ' ' + secondChunk + ' ' + thirdChunk + ' ' + fourthChunk);
			halt;
		end;



	end;	// if sentenceType = 5


	if identifierList.count > 0 then begin

		loopCount := 0;
		numPeriodsFound := 0;
		foundDollar := FALSE;
		isProcedure := FALSE;
		dollarString := '';
		foundChar := FALSE;

		if (leftStr(thirdChunk,1) = '`') and (rightStr(thirdChunk,1) = '`') then thirdChunk := midStr(thirdChunk,2,length(thirdChunk)-2);

		/////////////////////															///////
		/////////////////////		Check each entry in identifierList					///////
		/////////////////////															///////

		while endSHLoop = FALSE do begin
	
			testIdentifierEntry := identifierList.valueFromIndex[loopCount];	// writeln('    ' + testIdentifierEntry);

			if leftStr(testIdentifierEntry,1) = '0' then isProcedure := TRUE;
	
			innerLoopCount := 1;
			numColons := 0;
			numPeriodsFound := 0;

			identifierTestModuleName := '';
			identifierProcName := '';
			identifierTestIDName := '';
			testdollarString := '';

			canCall := FALSE;
			foundDuplicate := FALSE;
			foundDollar := FALSE;

	

			/////////////////////																			///////
			/////////////////////		Populate identifierTestModuleName and identifierTestIDName			///////
			/////////////////////																			///////

			while innerLoopCount <= length(testIdentifierEntry) do begin
	
				if numColons = 1 then begin
					if ansiLastChar(leftStr(testIdentifierEntry,innerLoopCount)) = '1' then canCall := TRUE;
				end;
	
				if numColons = 3 then begin
	
					if ansiLastChar(leftStr(testIdentifierEntry,innerLoopCount)) <> ':' then begin

						if ansiLastChar(leftStr(testIdentifierEntry,innerLoopCount)) <> '.' then begin
		
							if ansiLastChar(leftStr(testIdentifierEntry,innerLoopCount)) = '$' then foundDollar := TRUE;
		
							if foundDollar = FALSE then identifierTestIDName := identifierTestIDName + ansiLastChar(leftStr(testIdentifierEntry,innerLoopCount));
	
							if foundDollar = TRUE then testdollarString := testdollarString + ansiLastChar(leftStr(testIdentifierEntry,innerLoopCount));
		
						end;

						if ansiLastChar(leftStr(testIdentifierEntry,innerLoopCount)) = '.' then begin
							numPeriodsFound := numPeriodsFound + 1;
							if numPeriodsFound = 1 then identifierTestModuleName := identifierTestIDName;
							if numPeriodsFound = 2 then identifierProcName := identifierTestIDName;
							identifierTestIDName := '';
						end;

					end;
	
	
				end;

				if ansiLastChar(leftStr(testIdentifierEntry,innerLoopCount)) = ':' then numColons := numColons + 1;

				if numColons = 4 then begin
					if leftStr(testIdentifierEntry,1) = '0' then identifierProcName := identifierTestIDName;		// found local procedure call
					innerLoopCount := length(testIdentifierEntry);
				end;
	
				innerLoopCount := innerLoopCount + 1;
	
			end;	// while innerLoopCount <= length(testIdentifierEntry)

			//
			//	check for duplicate entries
			//

			foundDuplicateID := FALSE;

			if identifierTestModuleName = currentModule then begin

				if secondChunk = identifierTestIDName then foundDuplicateID := TRUE;
				if secondChunk = identifierProcName + '.' + identifierTestIDName then foundDuplicateID := TRUE;

				if foundDuplicateID = TRUE then begin
		
					writeln('Found duplicate identifier name.  Halting compilation.');
					writeln('    offending file: ' + currentModuleFile);
					write('    line number: ');  writeln(currentLineNumber);
					write('    line chunks: ');  writeln(firstChunk + ' ' + secondChunk + ' ' + thirdChunk + ' ' + fourthChunk);
					halt;
				end;

			end;
<</statement_handler>>

Here we identify variable assignments (actual translation will be done outside the loop).


<<statement_handler>>

			/////////////////////												///////
			/////////////////////			Test variable assignments			///////
			/////////////////////												///////
		
			if sentenceType = 4 then begin
			
				if firstChunk = identifierTestIDName then begin

					if leftStr(testIdentifierEntry,1) = '2' then begin
						foundChar := TRUE;
						endSHLoop := TRUE;

						calledModule := identifierTestModuleName;

						dollarString := testdollarString;
						nthListEntry := identifierList.indexOf(testIdentifierEntry);	// will use this value later

					end;

				end;

				if tabCount <> properIndent then begin

					writeln('Statements enclosed within a procedure declaration, a function declaration, a conditional or a loop need to be indented.  Halting compilation.');
					halt;
				end;
			
			end;	// if sentenceType = 4


<</statement_handler>>

Here we take care of variable declarations.  In Straightjacket, variable declarations look like this:

	var something is char

The keyword "var" marks a sentence as a variable declaration.  Unlike in Pascal, this keyword must be present with every variable declaration.  On the upside, variable declarations don't have to be grouped together.  The placeholder "something" stands for the name of the new variable.  The keyword "is" is just syntactic sugar to make the sentence easier to read, and the keyword "char" indicates that the variable is an 8-bit extended ascii character.

Straightjacket implementations should support at least two character types:  char (representing 8-bit extended ascii characters) and char16 (representing utf-16 characters).  While other character types can certainly be supported (char32, char_ebcdic and char_ascii come to mind), they're probably not necessary for most uses and are therefore not part of the language definition.  As a rule, I suggest avoiding support for multi-byte characters (like utf-8 and TRON) as character types, because they can be more easily and more compactly supported by extended ascii-formatted strings.

On the LLVM side, nothing needs to be written because LLVM variables aren't declared before they're assigned (or, if you prefer, they're defined when they're used).  Nevertheless, we still need to record the declaration info so that when a variable is used in Straightjacket, we can verify that it's being used correctly.


<<statement_handler>>
			/////////////////////												///////
			/////////////////////			Test variable declarations			///////
			/////////////////////												///////
		
			if sentenceType = 5 then begin

				if leftStr(testIdentifierEntry,1) = '2' then begin
					foundDupDecl := pos(secondChunk,testIdentifierEntry);

					if foundDupDecl > 0 then begin
						writeln('Found duplicate identifier declaration.  Halting compilation.');
						writeln('    offending file: ' + currentModuleFile);
						write('    line number: ');  writeln(currentLineNumber);
						write('    line chunks: ');  writeln(firstChunk + ' ' + secondChunk + ' ' + thirdChunk + ' ' + fourthChunk);
						halt;
					end;

				end;

			end;	// if sentenceType = 5
		
	
<</statement_handler>>

Here we process procedure calls.  In Straightjacket, a call to a procedure located within the current module looks like this:

	proc()

Calling a procedure exported from another module and imported into the current module looks like this:

	modulename.proc()

In LLVM, procedure calls look like this:

	call void @modulename.proc()

Here, "void" tells LLVM that the function doesn't return a value (this will be true for all Straightjacket procedures).  The @ prefix marks an identifier as being global.  This works because my compiler makes all identifiers global, using modules to mangle the names to avoid collisions.  

Please note that this has been done to make the compiler simpler, and that Straightjacket's scoping rules still should still be enforced before translation occurs.


<<statement_handler>>
			/////////////////////											///////
			/////////////////////			Handle procedure calls			///////
			/////////////////////											///////
		
			if sentenceType = 6 then begin
		
				modNameTarget := '';
				procName := '';
				procNameCount := 1;
				changeCount := 0;
				endInnerLoopProcCall := FALSE;
				foundProcMatch := FALSE;
		
				//
				// pulling module and procedure call info from results of getchunks
				// modNameTarget and procname
				//
			
				while endInnerLoopProcCall = FALSE do begin
		
					if rightstr(leftstr(firstChunk,procNameCount),1) = '.' then changeCount := changeCount + 1;
		
					if changeCount = 0 then begin
							modNameTarget := modNameTarget + rightstr(leftstr(firstChunk,procNameCount),1);
		
							if procNameCount = length(firstChunk) then begin
								procName := modNameTarget;
								modNameTarget := currentModule;
								endInnerLoopProcCall := TRUE;
							end;
					end;
		
					if changeCount = 1 then begin
						if rightstr(leftstr(firstChunk,procNameCount),1) <> '.' then procName := procName + rightstr(leftstr(firstChunk,procNameCount),1);
					end;
		
					procNameCount := procNameCount + 1;
					if procNameCount = length(firstChunk)+1 then endInnerLoopProcCall := TRUE;
		
				end;	// while endInnerLoopProcCall = FALSE


	
				// identifierList.add('0:' + privacyFlag + ':' + numParameters + ':' + currentModule + '.' + currentSub + ':0:' + subrParams);
				// the format is this:  <identifier type>:<privacy flag>:<number of parameters>:<identifier name>:<return type>:<parameter types>
	
				endMCLoop := FALSE;
				testModuleName := '';
				loopMCcount := 0;
				verifiedCall := FALSE;
		
				//
				// looping through modulePath to make sure that we're calling something in a module that was imported by the current module
				// identifierTestModuleName and identifierTestIDName
				//
		
				while endMCLoop = FALSE do begin
		
					testModuleName := modulePath.valueFromIndex[loopMCcount];
		
					throwawayModulePath := lowercase(currentModule) + ';' + lowercase(identifierTestModuleName);
	
					if ansiContainsStr(testModuleName, throwawayModulePath) then begin
						verifiedCall := TRUE;
						endMCLoop := TRUE;
					end;
		
					loopMCcount := loopMCcount + 1;
		
					if loopMCcount >= modulePath.Count then endMCLoop := TRUE;
		
				end;	// while endMCLoop = FALSE
		
				if lowercase(currentModule) = modNameTarget then begin		// allow intra-modular calls
					verifiedCall := TRUE;
					canCall := TRUE;
				end;
	

				//
				//	write out the procedure call
				//
	
				if isProcedure = TRUE then begin

					if verifiedCall = TRUE then begin
					if canCall = TRUE then begin
					if identifierTestIDName = procname then begin
		
						write(module_output,chr(9) + 'call void @' + modNameTarget + '.' + procName + '(');
						writeln(module_output,')');
		
						callList.add(identifierTestModuleName + '.' + currentSub + ':' + modNameTarget + '.' + procName);
							// we'll use this call list later to weed out unused identifiers
		
						foundProcMatch := TRUE;

						endSHLoop := TRUE;

	
					end;
					end;
					end;

				end;
	
		
				if isProcedure = FALSE then begin
		
					writeln('Found procedure call to an identifier that isn''t a procedure.  Halting compilation.');
					writeln('    offending file: ' + currentModuleFile);
					write('    line number: ');  writeln(currentLineNumber);
					write('    line chunks: ');  writeln(firstChunk + ' ' + secondChunk + ' ' + thirdChunk + ' ' + fourthChunk);
					halt;
				end;
		


			end;	// if sentenceType = 6


			loopCount := loopCount + 1;

			if loopCount >= identifierList.count then endSHLoop := TRUE;

		end;	// while endSHLoop = FALSE

	end;	// if identifierList.count > 0

	if sentenceType = 6 then begin
	if foundProcMatch = FALSE then begin

		writeln('Found call to procedure outside the current scope.  Halting compilation.');
		writeln('    offending file: ' + currentModuleFile);
		write('    line number: ');  writeln(currentLineNumber);
		write('    line chunks: ');  writeln(firstChunk + ' ' + secondChunk + ' ' + thirdChunk + ' ' + fourthChunk);
		halt;
	end;
	end;

	/////////////////////													///////
	/////////////////////			Finish variable declarations			///////
	/////////////////////													///////

	if (sentenceType = 5) AND (foundDupDecl = 0) then begin

		endInnerLoop := FALSE;
		loopCount := pos('`',fourthChunk) + 1;
		variableValue := '';

		//
		// extract the initialization value (if present)
		//

		if (pos(',',fourthChunk) > 0) AND (rightStr(fourthChunk,1) = '`') AND (pos('`',fourthChunk) < length(fourthChunk)) then begin
			while endInnerLoop = FALSE do begin

				variableValue := variableValue + rightStr(leftStr(fourthChunk,loopCount),1);

				loopCount := loopCount + 1;
				if loopCount = length(fourthChunk) then endInnerLoop := TRUE;

			end;
		end;

		//
		// update identifierList, remembering to account for significant whitespace
		//

		if tabCount = 0 then identifierList.add('2:' + privacyFlag + ':' + readOnlyProp + ':' + currentModule + '.' + secondChunk + ':0:1:' + variableValue);
		if tabCount > 0 then identifierList.add('2:' + privacyFlag + ':' + readOnlyProp + ':' + currentModule + '.' + currentSub + '.' + secondChunk + ':0:0:' + variableValue);

		if pos('char',fourthChunk) > 0 then intSize := 8;

		//
		// write global variables
		//

		if tabCount = 0 then begin

			if variableValue <> '' then begin
				writeln(module_output,'ret void');
				writeln(module_output,'}');
				writeln(module_output,'');	
				currentSub := '';
				finishedSubr := TRUE;
				properIndent := properIndent - 1;

				write(module_output, '@' + secondChunk + ' = global i');
				write(module_output, intSize);
				write(module_output, ' ');
				fourthChunk := variableValue;		// setting the value that the expression handler will look at
				expression_handler(2,fourthChunk);
				writeln(module_output,'');
			end;

			if variableValue = '' then begin

				writeln('Found uninitialized global variable.  Halting compilation.');
				writeln('    offending file: ' + currentModuleFile);
				write('    line number: ');  writeln(currentLineNumber);
				write('    line chunks: ');  writeln(firstChunk + ' ' + secondChunk + ' ' + thirdChunk + ' ' + fourthChunk);
				halt;

			end;

		end;

	end;	// if (sentenceType = 5) AND (foundDupDecl > 0)

<</statement_handler>>

Here we handle variable assignments.  Earlier we checked to make sure the variable is of the right type and that it had already been declared.  Now we need to double-check that character literals are formatted correctly and that they're indented properly.  If everything looks good, we can call the expression handler to write an llvm integer to the output file.

Here I'd like to say a word about static single assignment (SSA), which is required by llvm.  Whenever we assign a new value to a variable in straightjacket, we have create a new llvm variable that depends on the value of the previous variable.  To avoid collisions, I've decided to implement this using hashtags.  Basically, we add a dollar sign to the end of a variable name, and then append a number.  Whenever we give that variable a new value, we increment the final number and make that the new variable.  When we enter a procedure, function, branch or loop, we append another dollar sign and another number, and we start iterating that number.  When we leave a branch or a loop, we remove the last dollar sign and number.


<<statement_handler>>
	/////////////////////												///////
	/////////////////////			Handle variable assignments			///////
	/////////////////////												///////

	if sentenceType = 4 then begin

		if foundChar = FALSE then begin
			writeln('Variable found isn''t of type "char".  Halting compilation.');
			writeln('    offending file: ' + currentModuleFile);
			write('    line number: ');  writeln(currentLineNumber);
			write('    line chunks: ');  writeln(firstChunk + ' ' + secondChunk + ' ' + thirdChunk + ' ' + fourthChunk);
			halt;
		end;

		if tabCount = 0 then begin
			writeln('Variable assignments must be made within subroutines.  Halting compilation.');
			writeln('    offending file: ' + currentModuleFile);
			write('    line number: ');  writeln(currentLineNumber);
			write('    line chunks: ');  writeln(firstChunk + ' ' + secondChunk + ' ' + thirdChunk + ' ' + fourthChunk);
			halt;
		end;

		if foundChar = TRUE then intSize := 8;	// the width of all char-type variables is 8 bits

		count := 1;

		while count <= tabCount do begin

			write(module_output,chr(9));
			count := count + 1;

		end;
	
		

		//
		// updating the variable name to account for SSA
		//
	
		intName := firstChunk;
		dollarFound := 0;
		endDollarLoop := FALSE;
		charPos := 1;
	
		while endDollarLoop = FALSE do begin
	
			if dollarFound < tabCount then begin
				intName := intName + rightStr(leftStr(dollarString,charPos),1);
				if rightStr(leftStr(dollarString,charPos),1) = '$' then dollarFound := dollarFound + 1;
			end;
	
			if dollarFound = tabCount then begin
	
				intName := intName + intToStr(strToInt(rightStr(dollarString,length(dollarString)-charPos)) + 1);
					// convert the remaining characters to an integer
					// iterate that integer
					// convert that integer to a string
					// append that string to intName
	
				endDollarLoop := TRUE;
			end;
	
			charPos := charPos + 1;
			if charPos > length(dollarString) then endDollarLoop := TRUE;					
	
		end;
	
		if dollarFound = 0 then intName := intName + '$1';
	
		//
		// update identifierList with the new name
		//
	
	
		testIdentifierEntry := identifierList.valueFromIndex[nthListEntry];		// writeln('testIdentifierEntry: ' + testIdentifierEntry);
	
		innerLoopCount := -1;
		numColons := 0;
		dumpStr := '';
		endInnerLoop := FALSE;
	
		while endInnerLoop = FALSE do begin
	
			innerLoopCount := innerLoopCount + 1;
	
			if rightStr(leftStr(testIdentifierEntry,innerLoopCount),1) = ':' then numColons := numColons + 1;
	
			if numColons = 3 then endInnerLoop := TRUE;
	
		end;
	
	
		if calledModule <> '' then calledModule := calledModule + '.';
		if identifierProcName <> '' then identifierProcName := identifierProcName + '.';
	
		dumpStr := leftStr(testIdentifierEntry, innerLoopCount) + calledModule + identifierProcName + firstChunk;
	
		innerLoopCount := innerLoopCount + length(firstChunk);
	
	
		if dollarString = '' then dollarString := '$1';
	
	
	
		if dollarString <> '' then begin
	
			dollarFound := 0;
			endInnerLoop := FALSE;
			dollarNumStr := '0';
			dollarString := '';
	
			while endInnerLoop = FALSE do begin
	
				innerLoopCount := innerLoopCount + 1;
	
				if rightStr(leftStr(testIdentifierEntry,innerLoopCount),1) = ':' then begin
	
					if dollarFound = 0 then begin
						dumpStr := dumpStr + '$1';
						dollarString := dollarString + '$1';
					end;

					if dollarFound > 0 then begin
						dollarString := '$' + intToStr(strToInt(dollarNumStr) + 1);
						dumpStr := dumpStr + dollarString + ':';
					end;

					endInnerLoop := TRUE;
	
				end;
	
				if rightStr(leftStr(testIdentifierEntry,innerLoopCount),1) <> ':' then begin
	
					if rightStr(leftStr(testIdentifierEntry,innerLoopCount),1) <> '$' then dollarNumStr := dollarNumStr + rightStr(leftStr(testIdentifierEntry,innerLoopCount),1);
	
					if rightStr(leftStr(testIdentifierEntry,innerLoopCount),1) = '$' then begin
						dollarNumStr := '';
						dollarFound := dollarFound + 1;
					end;

				end;

			end;	// 	while endInnerLoop = FALSE

	
		end;	// if dollarString <> ''
	
	
		while innerLoopCount <= length(testIdentifierEntry) do begin
	
			dumpStr := dumpStr + rightStr(leftStr(testIdentifierEntry,innerLoopCount),1);
			innerLoopCount := innerLoopCount + 1;
	
		end;
	

		identifierList.delete(nthListEntry);
		identifierList.add(dumpStr);


		count := 0;

		while count < identifierList.count do begin

			dumpStr := identifierList.valueFromIndex[count];

			innerLoopCount := 1;
			numColons := 0;
			testOldValueStr := '';
			endLoop := FALSE;

			if leftStr(dumpStr,1) <> '2' then innerLoopCount := length(dumpStr) + 1;	// skip over list entries that aren't characters

			while endLoop = FALSE do begin

				if rightStr(leftStr(dumpStr,innerLoopCount),1) = ':' then numColons := numColons + 1;

				if (rightStr(leftStr(dumpStr,innerLoopCount),1) <> ':') AND (numColons = 5) then testOldValueStr := testOldValueStr + rightStr(leftStr(dumpStr,innerLoopCount),1);

				innerLoopCount := innerLoopCount + 1;
				if innerLoopCount >= length(dumpStr) then endLoop := TRUE;
			end;

			count := count + 1;

		end;	// while count < identifierList.count

		if leftStr(rightStr(dumpStr,3),1) = '1' then begin
			write(module_output, 'store i');
			write(module_output,intSize);
			write(module_output,' ');

			expression_handler(2,thirdChunk);

			write(module_output, ', i');
			write(module_output,intSize);
			writeln(module_output,'* @' + firstChunk);
		end;


		if leftStr(rightStr(dumpStr,3),1) = '0' then begin
			write(module_output, '%' + firstChunk + dollarString + ' = ' + 'add i');
			write(module_output,intSize);
			write(module_output,' 0,');

			expression_handler(2,thirdChunk);

			writeln(module_output,' ');
		end;



	end;	// if sentenceType = 4


end;
<</statement_handler>>

Now is probably a good time to look at the expression_handler() procedure.  This procedure takes the right-hand side of an assignment statement and translates it into LLVM code.  Because the only data type right now is type char, and because no expression operators are defined for this type, the expression_handler simply has to translate character literals into integers.


<<expression_handler>>

procedure expression_handler (varType:integer; expressionStr:string);		// modify to accept the nth entry of expressionStr

var		minN			:	integer;
		maxN			:	integer;
		intLength		:	integer;
		charPos			:	integer;
		maxNumRange		:	integer;
		minN2			:	integer;
		maxN2			:	integer;
		n				:	integer;
		intValue		:	integer;
		count			:	integer;
		innerLoopCount	:	integer;
		numColons		:	integer;
		tryNum			:	integer;

		testOldIDname	:	string;
		testOldValueStr	:	string;
		tryString		:	string;

		endXvarAssLoop	:	boolean;
		charCheckLoop	:	boolean;
		legalChar		:	boolean;
		endLoop			:	boolean;
		endTries		:	boolean;


begin

	if varType = 2 then begin

		// if sentenceType = 4 then check identifierList for matches for thirdStr
		// if match is found, then substitute the old value of the variable for expressionStr

		if sentenceType = 4 then begin

			endTries := FALSE;
			tryString := '';
			tryNum := 1;

			while endTries = FALSE do begin
			
				if tryNum = 1 then tryString := currentModule + '.' + currentSub + '.' + thirdChunk;
				if tryNum = 2 then tryString := currentModule + '.' + thirdChunk;

				count := 0;
	
				while count < identifierList.count do begin
	
					dumpStr := identifierList.valueFromIndex[count];

					innerLoopCount := 1;
					numColons := 0;
					testOldIDname := '';
					testOldValueStr := '';
					endLoop := FALSE;
	
					if leftStr(dumpStr,1) <> '2' then endLoop := TRUE;	// skip over list entries that aren't characters
	
					while endLoop = FALSE do begin
	
						if rightStr(leftStr(dumpStr,innerLoopCount),1) = ':' then numColons := numColons + 1;
	
						if (rightStr(leftStr(dumpStr,innerLoopCount),1) <> ':') AND (numColons = 3) then testOldIDname := testOldIDname + rightStr(leftStr(dumpStr,innerLoopCount),1);
	
						if numColons = 4 then begin
								if testOldIDname = tryString then begin
								expressionStr := rightStr(dumpStr,1);
								endLoop := TRUE;
								count := identifierList.count;
							end;
						end;
	
						innerLoopCount := innerLoopCount + 1;
						if innerLoopCount >= length(dumpStr) then endLoop := TRUE;

					end;
	
					count := count + 1;
	
				end;	// while count < identifierList.count

				tryNum := tryNum + 1;
				if tryNum = 3 then endTries := TRUE;

			end;	// while endTries = FALSE

		end;	// if sentenceType = 4

		charCheckLoop := FALSE;
		intLength := length(expressionStr);
		legalChar := TRUE;
		if intLength = 0 then legalChar := FALSE;
		if intLength > 3 then legalChar := FALSE;

		if legalChar = FALSE then begin
			writeln('Found illegal value for character literal.  Character literals may be printable ascii characters, two-digit hexadecimal numbers preceded by single backslashes, or any of the following switches:  \t  \n  \f  \r  \e  \\  \`');

			writeln('    offending file: ' + currentModuleFile);
			write('    line number: ');  writeln(currentLineNumber);
			write('    line chunks: ');  writeln(firstChunk + ' ' + secondChunk + ' ' + thirdChunk + ' ' + fourthChunk);
			halt;
		end;


<</expression_handler>>


Straightjacket supports a few c-styleswitches to represent commonly used non-printing characters.  These switches are included:

	\t		horizontal tab
	\n		line feed
	\f		form feed
	\r		carriate return
	\e		escape
	\\		backslash
	\`		reverse accent


These two switches will make character representations more consistent with string representations (strings contain more than one character, and string literals are surrounded by the ` character).


<<expression_handler>>


		if (intLength = 2) AND (leftStr(expressionStr,1) = '\') then begin
			case rightStr(thirdChunk,1) of
				't', 'n', 'f', 'r', 'e', '\', '`':	legalChar := TRUE;
			end;
		end;

		// printed one-character literals must fall within one of the printable
		// ascii characters.

		if (intLength = 1) AND (leftStr(expressionStr,1) <> '\') AND (leftStr(expressionStr,1) <> '`') then begin

			charPos := 1;
			maxNumRange := 1;

			minN := 32;			// space character
			maxN := 126;		// tilde character

			charCheckLoop := TRUE;

		end;

		// straightjacket supports hexadecimal switches for extended-ascii literals.
		// they look like this:  \00

		if (intLength = 3) AND (leftStr(expressionStr,1) = '\') then begin

			charPos := 2;
			maxNumRange := 2;

			minN := 48;			// 0
			maxN := 57;			// 9

			minN2 := 97;			// a
			maxN2 := 102;		// f

			charCheckLoop := TRUE;

		end;

		endXvarAssLoop := FALSE;


		// loop through the proper ascii ranges for one- and three-character
		// ascii literals

		n := minN;

		if charCheckLoop = TRUE then begin
			while endXvarAssLoop = FALSE do begin

				legalChar := FALSE;

				if rightStr(leftStr(expressionStr,charPos),1) <> chr(n) then n := n + 1;

				if rightStr(leftStr(expressionStr,charPos),1) = chr(n) then begin
					if maxNumRange = 1 then endXvarAssLoop := TRUE;
					if maxNumRange = 2 then begin
						n := minN2;
						maxN := maxN2;
					end;
				end;

				if (n > maxN) then begin
					writeln('Found illegal value for character literal.  Character literals may be printable ascii characters, two-digit hexadecimal numbers preceded by single backslashes, or any of the following switches:  \t  \n  \f  \r  \e  \\  \`');

					writeln('    offending file: ' + currentModuleFile);
					write('    line number: ');  writeln(currentLineNumber);
					write('    line chunks: ');  writeln(firstChunk + ' ' + secondChunk + ' ' + thirdChunk + ' ' + fourthChunk);
					halt;
				end;

			end;
		end;

<</expression_handler>>


Now that everything has been verified, we can try to write down the integers.  This requires us to know three things:  the integer that corresponds to the character literal, the variable name and the static single assignment modifier.


<<expression_handler>>


		//
		// setting the numeric values for the output integers
		//
	
		if length(expressionStr) = 1 then intValue := ord(expressionStr[1]);
	
		if length(expressionStr) = 2 then begin
			case rightStr(expressionStr,1) of
			 't' : intValue := 9;		// tab
			 'n' : intValue := 10;		// line feed
			 'f' : intValue := 12;		// form feed
			 'r' : intValue := 13;		// carriage return
			 'e' : intValue := 27;		// escape
			 '\' : intValue := 92;		// backslash
			 '`' : intValue := 96;		// grave accent
			end;
		end;
	
		if length(expressionStr) = 3 then intValue := strToInt('x' + rightStr(expressionStr,2));
	

	end;	// if varType = 2

	write(module_output,intToStr(intValue));

	//
	//	delete the old identifierList entry and replace with an entry that has the new value
	//

	// if sentenceType = 4 then check identifierList for matches for expressionStr
	// if match is found, then update the new value

	if sentenceType = 4 then begin

		count := 0;

		while count < identifierList.count do begin

			dumpStr := identifierList.valueFromIndex[count];

			innerLoopCount := 1;
			numColons := 0;
			testOldIDname := '';
			testOldValueStr := '';
			endLoop := FALSE;

			if leftStr(dumpStr,1) <> '2' then innerLoopCount := length(dumpStr) + 1;	// skip over list entries that aren't characters

			while endLoop = FALSE do begin

				if rightStr(leftStr(dumpStr,innerLoopCount),1) = ':' then numColons := numColons + 1;

				if (rightStr(leftStr(dumpStr,innerLoopCount),1) <> ':') AND (numColons = 3) then testOldIDname := testOldIDname + rightStr(leftStr(dumpStr,innerLoopCount),1);

				if (numColons = 4) AND (testOldIDname <> expressionStr) then endLoop := TRUE;		// if no match, end the loop

				if (rightStr(leftStr(dumpStr,innerLoopCount),1) = ':') AND (numColons = 6) then identifierList.delete(count);

				if (rightStr(leftStr(dumpStr,innerLoopCount),1) <> ':') AND (numColons = 6) then testOldValueStr := testOldValueStr + rightStr(leftStr(dumpStr,innerLoopCount),1);

				innerLoopCount := innerLoopCount + 1;
				if innerLoopCount >= length(dumpStr) then endLoop := TRUE;
			end;

			if testOldValueStr <> '' then begin
				identifierList.add(leftStr(dumpStr,innerLoopCount-1)+ ':' + testOldValueStr);
				expressionStr := testOldValueStr;
				count := identifierList.count;
			end;

			count := count + 1;

		end;	// while count < identifierList.count


	end;	// if sentenceType = 4

end;

<</expression_handler>>

Finally, we need to wrap up the main program.

If firstChunk is empty (which could happen if an input line contained only tabs), then we want to ignore it and move on.  However, if we find anything else at this point, then the program should print an error and halt.

<<compiler_end>>



//
//	Finish up the main program.
//

writeln;
writeln('found end of main program');


end.

<</compiler_end>>


Appendix:  Literate Handling


If the input file was written in the literate style, then we want to extract the source code from the literate document.  We might need to do the same thing for any imported header files as well, so let's define this code as a procedure that we can call from several places.  Luckily, I've already written a literate programming tool, so I'll just re-use the code for that purpose.

Basically, the literate code takes a text file written using tags (just like the ones used in this document), extracts the program code and then writes it in order to an output text file.  That output will then be re-used as the input file by the rest of the compiler.

Here I'm just going to dump the literate code between two "literate" tags, rather than explaining it in detail.


<<literate>>

///////////////////////////////////////////////									///////
///////////////////////////////////////////////			Procedure literate		///////
///////////////////////////////////////////////									///////

procedure literate (var currentFile:text); 

var	endWSSearch			:	integer;
	foundWS				:	integer;
	foundTag			:	integer;
	fileCount			:	integer;
	searchTags			:	integer;
	currentLineNumberL	:	integer;

	output_file			:	text;
	grabFile			:	text;

	tagList				:	TStringList;

	stringBuffer		:	string;
	currentTag			:	string;
	intString			:	string;

begin

	writeln('Starting the literate section now.');

	if isLiterate = TRUE then begin

		currentTag := '';
	
		tagList := TStringList.Create;		// create a list of strings in memory
		
		writeln;
		writeln('mode 0: looking for <<def>> tag');
		currentLineNumberL := 1;
		
		while not EOF(currentFile) do begin
		
			foundTag := 0;
			endWSSearch := 0;
			countLetters := 1;
			stringBuffer := '';
			workingString := '';
		
			readln(input_file,stringBuffer);
			workingString := trim(stringBuffer);
			currentLineNumberL := currentLineNumberL + 1;
		
			// after we've found a tag, start exporting lines to the output file
			// stop when we reach the end tag
		
			// note:  the modes are in reverse order so that the two modes never activate on the same line
		
			if mode = 3 then begin
		
			  if workingString[1] = '<' then begin
			    if workingString[2] = '<' then begin
				if workingString[3] = '/' then begin
		
					if lowerCase(workingString) = '<</' + currentTag + '>>' then begin
		
						writeln('found end tag.  switching back to mode 2.');
						mode := 2;
						close(output_file);
		
					end;
		
					if lowerCase(workingString) <> '<</' + currentTag + '>>' then begin
		
						write('Error: End tag at line number ');
						write(currentLineNumberL);
						writeln(' doesn' + chr(39) + 't match the begin tag.');
		
						halt;
					end;
		
		
				end;  // if workingString[3] = '/'
			    end;  // if workingString[2] = '<'
			  end;  // if workingString[1] = '<'
	
	
		
				if workingString[1] <> '<' then begin
					if workingString <> '' then begin
						str(currentLineNumberL, intString);
					
						intString := intString + ' ';
						intString := intString + stringBuffer;
						stringBuffer := intString;
					
						writeln(output_file, stringBuffer);
					end;
				end;
	
		
			end; // if mode = 3
		
		
		
			// after we've reached the end of the tag definition section, start looking for tags
			// when we find a tag, start exporting stringBuffers to output files
		
			if mode = 2 then begin
	
	
	
				searchTags := 1;
				indexValue := 0;
		
				while searchTags = 1 do begin

					if tagList.Count < 1 then searchTags := 0;
		
					if tagList.Count > 0 then begin
	
						if workingString <> '' then begin
	
						  if lowerCase(workingString) = '<<' + tagList.ValueFromIndex[indexValue] + '>>' then begin
		
							currentTag := tagList.ValueFromIndex[indexValue];
							foundTag := 1;
							searchTags := 0;
							mode := 3;
		
							writeln('found tag ' + chr(34) + currentTag + chr(34));
							writeln('mode 3: looking for text to extract');
		
						  end;
		
			
						end;
			
						if workingString = '' then searchTags := 0;
					end;
		
					indexValue := indexValue + 1;
		
					if indexValue > tagList.Count - 1 then searchTags := 0;
		
				end;
		
				if foundTag = 1 then begin

					fileName := 'C:\Users\meterwin\Desktop\straightjacket\working\' + currentTag + '.txt';
		
					assign(output_file,fileName);
		
					If NOT FileExists(fileName) then begin
						rewrite(output_file);
						close(output_file);
					end;
		
					append(output_file);

	
				end;
		
			end;	// if mode = 2
		
		
			// when the define tag has been found, add lines to the tag list
			// mode = 2 when we reach the end of the defined tags
			// error and quit if a tag contains a space or a tab
			// otherwise, add the tag to the tag list
		
			if mode = 1 then begin
		
	
	
				if lowerCase(workingString) = '<</def>>' then begin
					mode := 2;
					writeln('mode 2: looking for tags in tagList');
				end;
		
				if lowerCase(workingString) <> '<</def>>' then begin
		
					while endWSSearch = 0 do begin
		
						if countLetters <= length(workingString) then begin
		
							if workingString[countLetters] = ' ' then begin
								endWSSearch := 1;
								foundWS := 1;
							end;
		
							if workingString[countLetters] = chr(9) then begin
								endWSSearch := 1;
								foundWS := 1;
							end;
		
						end;
		
						countLetters := countLetters + 1;
		
						if countLetters > length(workingString) then endWSSearch := 1;
		
					end;	// while endWSSearch = 0
		
		
					if foundWS = 1 then begin
		
						write('Error: Found whitespace within tag at line number ');
						write(currentLineNumberL);
						writeln('.  Exiting program.');
		
						halt;
					end;
		
					if foundWS <> 1 then tagList.Add(lowerCase(workingString));
		
					writeln('added tag '+ lowerCase(workingString));
		
		
				end;	// if workingString <> '<</def>>'
		
			end;	// if mode = 1
		
		
		
		
		
		
			// for mode = 0, look for the define tag
		
			if mode = 0 then begin
		
				if lowerCase(workingString) = '<<def>>' then mode := 1;
				writeln('found <<def>> tag');
				writeln('mode 1: looking for tags');

			end;
		
		end;	// while not EOF(input_file)
	
		close(input_file);
	
		assign(literate_output, 'C:\Users\meterwin\Desktop\source code\working\output.txt');
		rewrite(literate_output);
		append(literate_output);
	
		
		//
		// now that we've extracted every snippet of source code, let's reassemble all of the pieces in order.
		//
		
		writeln('found end of input file.  writing to the output file now.');
		
		fileCount := 0;
		
		while fileCount <= tagList.Count - 1 do begin
		
			currentTag := tagList.ValueFromIndex[fileCount];
			fileName := 'C:\Users\meterwin\Desktop\straightjacket\working\' + currentTag + '.txt';
		
			If NOT FileExists(fileName) then begin
		
				writeln('File "' + fileName + '" not found.  Tag ' + chr(34) + currentTag + chr(34) + ' may not have been used.');
				halt;
			end;
		
			If FileExists(fileName) then begin
		
				assign(grabFile,fileName);
				reset(grabFile);
		
				while not EOF(grabFile) do begin
		
					readln(grabFile,stringBuffer);
					writeln(literate_output,stringBuffer);
		
				end;
		
				close(grabFile);
	
			end;
		
			fileCount := fileCount + 1;
		
		end;
		
		close(literate_output);
		
		
		//
		// delete the tag files (useful for testing)
		//
		
		writeln('finished writing output.  cleaning up temporary files...');
		
		fileCount := 0;
		
		while fileCount <= tagList.Count - 1 do begin
		
			currentTag := tagList.ValueFromIndex[fileCount];
			fileName := 'C:\Users\meterwin\Desktop\straightjacket\working\' + currentTag + '.txt';
		
			If NOT FileExists(fileName) then writeln('File "' + fileName + '" not found.');
		
			If FileExists(fileName) then begin
				assign(grabFile,fileName);
				deleteFile(fileName);
			end;
		
			fileCount := fileCount + 1;
		
		end;
		
		writeln('finished extracting text.');
	
		tagList.destroy;		// free up memory used by tagList, as it could be large, and it
								// will no longer be needed.
	
		//
		//	reassign input_file to the output of the literate code-handling section
		//
	
		assign(input_file, 'C:\Users\meterwin\Desktop\straightjacket\output.txt');
		reset(input_file);
	
	end;	// if isLiterate = TRUE
	
	mode := 0;

end;	// procedure literate

<</literate>>



Appendix:  Beginning text
---------------------------

The following section includes comments on the program, an inclusion of GNU General Public License, the declaration section and the begin statement of the program.




<<header>>

// Straightjacket reference compiler - Copyright  2012 Joshua Hanley

// If requested, this program copies out-of-order source code from a text file
// and writes it in-order to another text file.  It looks for text located between
// tags formatted like this:  <<tagName>>  It exports the text it finds into
// temporary files and then re-assembles the contents of those files in order.  To 
// define the proper output order, the program first looks for a list of tags 
// (without brackets) surrounded by <<def>> and <</def>> tags.  The final output
// will contain text from each declared tag, in the order given by the tag list
// within the <<def>> section.  The program will give an error and quit if a tag is
// not used, if an undeclared tag is used, if a tag is misspelled or if a section
// of text begins with one tag but is ended by another tag.  Tags are case-insensitive,
// they may not contain spaces and they may not be indented by tabs.


// Afterwards, the program treats the output of the literate section as the new input
// file.  Next, the program sorts each line of the input file into terms, collecting
// useful information as it goes.  If an input statement is encountered, the compiler
// loops through the input file, collecting and translating declarations.  This
// process is repeated until all of the input statements have been processed.  When a
// program statement is encountered, the compiler translates the statements it encounters.


//  This program is free software: you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with this program.  if not, see <http://www.gnu.org/licenses/gpl-3.0.html>.

//  You can reach the creator of Legible Assembler through the SourceForge page at http://legibleasm.sourceforge.net


program straightjacket_compiler;

uses classes, sysutils, strutils, crt;

///////////////////////////////////////////////												///////
///////////////////////////////////////////////												///////
///////////////////////////////////////////////			This is the declaration section		///////
///////////////////////////////////////////////												///////
///////////////////////////////////////////////												///////


var	mode				:	integer;
	countLetters		:	integer;
	numArgs				:	integer;
	indexValue			:	integer;
	currentLineNumber	:	integer;
	tabCount			:	integer;
	sentenceType		:	integer;
	subrType			:	integer;
	modCharTest			:	integer;
	modCharNum			:	integer;
	modulePathCount		:	integer;
	modulePathCount2	:	integer;
	modulePathCount3	:	integer;
	properIndent		:	integer;
	mainCount			:	integer;

	input_file			:	text;
	final_output		:	text;
	literate_output		:	text;
	module_file			:	text;
	module_output		:	text;

	identifierList		:	TStringList;
	modulePath			:	TStringList;
	callList			:	TStringList;

	firstArg			:	string;
	secondArg			:	string;
	workingString		:	string;
	firstChunk			:	string;
	secondChunk			:	string;
	thirdChunk			:	string;
	fourthChunk			:	string;
	currentModule		:	string;
	fileName			:	string;
	currentSub			:	string;
	testModuleEntry		:	string;
	moduleNameThrowAway	:	string;
	currentModuleFile	:	string;
	privacyFlag			:	string;
	numParameters		:	string;
	subrParams			:	string;
	dumpStr				:	string;


	isLiterate			:	boolean;
	isComment			:	boolean;
	endHeaderLoop		:	boolean;
	foundAlias			:	boolean;
	foundUnusedEntry	:	boolean;
	endRecheckModulePathList	:	boolean;
	foundDuplicate		:	boolean;
	finishedSubr		:	boolean;


<</header>>


